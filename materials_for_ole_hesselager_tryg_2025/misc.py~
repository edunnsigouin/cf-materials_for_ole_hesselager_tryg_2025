"""
Collection of useful miscellaneous functions
"""

import time
import numpy  as np
import xarray as xr
from scipy    import signal
import os
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

def tic():
    """
    matlab style tic function
    """
    global startTime_for_tictoc
    startTime_for_tictoc = time.time()
    return

def toc():
    """
    matlab style toc function
    """                        
    if 'startTime_for_tictoc' in globals():
        print("Elapsed time is " + str(time.time() - startTime_for_tictoc) + " seconds.")
    else:
        print("Toc: start time not set")
    return


def get_dim(flag):
    """   
    imports data dimensions given a grid 
    """
    if flag == 'seasonal': from climada import dim as dim    
    return dim


def xy_mean(ds):
    """ 
    calculates xy mean over dims lat and lon
    with cosine weighting in lat. Input is xarray
    dataarray or dataset
    """
    weights = np.cos(np.deg2rad(ds.latitude))
    ds      = ds.weighted(weights).mean(dim=('latitude','longitude'))
    return ds        

def remove_leap_year_days(data):
    """ 
    removes leap-year days from daily xrray dataset
    """
    return data.sel(time=~((data.time.dt.month == 2) & (data.time.dt.day == 29)))

def filter_winter_half_year_days(ds):
    """
    Filter for winter half year days (oct-nov-dec-jan-feb-mar)
    """
    return ds.sel(time =~ ((ds['time.dayofyear'] < 274) & (ds['time.dayofyear'] > 92)))


def is_leap_year(year):
    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
        return True
    else:
        return False

def get_season(ds,season):
    """
    Extracts times belonging to a given season
    input = xarray dataset or dataarray
    """
    months = ds['time.month']
    if season == 'ndjfm': index = (months >= 11) | (months <= 3)
    elif season == 'mjjas': index = (months >= 5) & (months <= 9)
    elif season == 'annual': index = (months >= 1) & (months <= 12)
    elif season == 'djf': index = (months >= 12) | (months <= 2)
    elif season == 'mam': index = (months >= 3) & (months <= 5)
    elif season == 'jja': index = (months >= 6) & (months <= 8)
    elif season == 'son': index = (months >= 9) & (months <= 11)
    elif season == 'jfm': index = (months >= 1) & (months <= 3)
    return ds.sel(time=index)


def to_netcdf_with_packing_and_compression(data, filename, dtype='int16', zlib=True, complevel=5):
    """
    Writes an xarray DataArray or Dataset to a NetCDF file, applying packing and zlib compression.
    
    Parameters:
    - data (xarray.DataArray or xarray.Dataset): The data to write to file.
    - filename (str): The path to the output NetCDF file.
    - dtype (str): The target dtype for packing. Default is 'int16'.
    - zlib (bool): Whether to apply zlib compression. Default is True.
    - complevel (int): Compression level from 1 to 9. Default is 5.
    """
    
    def calculate_scale_and_offset(min_val, max_val, dtype):
        """
        Calculate scale factor and add offset for packing data.
        Adds a buffer to avoid the minimum value being set to the fill value.
        """
        data_range = max_val - min_val
        int_min, int_max = np.iinfo(dtype).min, np.iinfo(dtype).max

        # Add a buffer to min_val to prevent it from becoming a fill value due to rounding
        buffer = data_range / (int_max - int_min)
        add_offset = min_val - buffer
        scale_factor = (max_val - add_offset) / (int_max - 1)  # Use int_max - 1 to ensure max value is representable

        return scale_factor, add_offset

    encoding = {}
    fill_value = np.iinfo(np.dtype(dtype)).min  # Use minimum representable value as fill value
    
    data_vars = list(data.data_vars) if isinstance(data, xr.Dataset) else [data.name]
    
    for var in data_vars:
        da = data[var] if isinstance(data, xr.Dataset) else data
        
        min_val = float(da.min())
        max_val = float(da.max())
        
        scale_factor, add_offset = calculate_scale_and_offset(min_val, max_val, dtype)
        
        encoding[var] = {
            'dtype': dtype,
            'scale_factor': scale_factor,
            'add_offset': add_offset,
            'zlib': zlib,
            '_FillValue': fill_value,
            'complevel': complevel
        }
    
    # Write the data to a NetCDF file with the specified encoding
    data.to_netcdf(filename, encoding=encoding)

    return


def create_custom_colormap_with_white_center(orig_cmap, levels):
    """
    Create a custom colormap that modifies an original colormap. If there is an even number of colors,
    the middle two colors are set to white. If there is an odd number of colors, the middle color is set to white.

    Parameters:
    orig_cmap (matplotlib.colors.Colormap): Original colormap to modify.
    levels (list of float): Levels at which the colors change.

    Returns:
    matplotlib.colors.Colormap: Customized colormap with white at the center.
    """
    n_colors = len(levels) - 1
    new_colors = plt.cm.get_cmap(orig_cmap)(np.linspace(0, 1, n_colors))

    if n_colors % 2 == 0:
        # Even number of colors; set the middle two colors to white
        middle_indices = [n_colors // 2 - 1, n_colors // 2]
        new_colors[middle_indices] = [1, 1, 1, 1]  # RGBA for white
    else:
        # Odd number of colors; set the middle color to white
        middle_index = n_colors // 2
        new_colors[middle_index] = [1, 1, 1, 1]  # RGBA for white

    return mcolors.ListedColormap(new_colors)

